R প্রোগ্রামিং: 1L, 2L, 3L কেন?


ধরুন আমরা একটা ভেক্টর বানালাম এরকম:

<textarea class="codebox" id="txt1" onclick="SelectAll('txt1');" rows="1">x <- c(1, 2, 3)</textarea>


class(x) দেখলে দেখা যাবে "numeric"। এবার একটু আলাদা করে লিখুন।

<textarea class="codebox" id="txt1" onclick="SelectAll('txt1');" rows="1">

y <- c(1L, 2L, 3L)

</textarea>


এবার class(x) দেখলে দেখা যাবে "integer"।

এখানেই পার্থক্য। শুধু 1, 2, 3 লিখলে  R ধরে নেয় এটা নিউমেরিক ভেক্টর। মানে সংখ্যাগুলোতে ভগাংশও থাকতে পারে।

তবে আমরা যদি জানি আমরা শুধু পূর্ণসংখ্যা নিয়ে কাজ করব তাহলে integer-এর ব্যবহার কাজের গতি বাড়িয়ে দিতে পারে। আর সেজন্যই x <- c(1L, 2L, 3L) লিখে আমরা নির্দিষ্ট করে বলে দেই, আমাদের ভেক্টরটা হবে ইন্টিজার ভেক্টর। এতে সুবিধা হলো ভেক্টরটা কম্পিউটারে কম মেমোরি দখল করবে। numeric ভেক্টর প্রতিটি ভ্যালুর জন্য ৮ বাইট ব্যবহার করে। integer সেখানে ব্যবহার করে ৪ বাইট।

object.size(x) দিয়ে ভেক্টরটার সাইজ দেখলে পাওয়া যায় ৬৪ বাইট। কিন্তু object.size(y) হলো ৮০ বাইট। ভেক্টরের মধ্যে শুধুই সংখ্যার সাইজ থাকলে আসলে হত যথাক্রমে ১২ ও ২৪ বাইট। কিন্তু আরও কিছু তথ্যও থাকে। এই যেমন এটা যে নিউমেরিক ভেক্টর সে তথ্যও মেমোরিতে থাকে। এগুলোকে ওভারহেড তথ্য। তাও বড় ডেটার ক্ষেত্রে ইন্টিজার ও নিউমেরিক ডেটার মধ্যে পার্থক্য গুরুত্বপূর্ণ হয়ে ওঠে। ইন্টিজার র‍্যামের ওপর প্রেশার কমাবে। কম্পিউটার সিপিইউ (CPU)কে দ্রুত কাজ করতে সহায়তা।

আরেকটা উদাহরণ দেখুন।

<textarea class="codebox" id="txt1" onclick="SelectAll('txt1');" rows="10">
x <- 1:100
typeof(x) # integer

y <- x+1
typeof(y) # double, twice the memory size
object.size(y) # 840 bytes (on win64), 848 bytes on Linux

z <- x+1L
typeof(z) # still integer
object.size(z) # 440 bytes (on win64), 448 bytes on Linux
</textarea>

তবে R দিয়ে ইন্টিজার বানাতে হলে $-2 \times 10^9$ থেকে $2 \times 10^9$-এর মধ্যে সংখ্যা থাকতে হবে।
